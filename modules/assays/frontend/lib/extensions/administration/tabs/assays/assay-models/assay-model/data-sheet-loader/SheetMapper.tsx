import {
  Button,
  ButtonGroup,
  ErrorPage,
  Menu,
  Portal,
  Spinner,
  Surface,
  Tabs,
  TooltipRender,
} from "@grit42/client-library/components";
import { Navigate, useNavigate } from "react-router-dom";
import {
  EndpointError,
  EndpointErrorErrors,
  EndpointSuccess,
  request,
  useMutation,
  useQuery,
} from "@grit42/api";
import {
  sampleSheetData,
  sheetDefinitionsFromFiles,
  Sheet,
  utils,
  defaultColumnDefinitionsFromSheetOptions,
  Column,
  columnDefinitionsFromSheet,
} from "@grit42/spreadsheet";
import { GritColumnDef, Row, Table } from "@grit42/table";
import { useEffect, useMemo, useRef, useState } from "react";
import styles from "./dataSheetStructureLoader.module.scss";
import {
  Form,
  FormField,
  FormFieldDef,
  ReactFormExtendedApi,
  useForm,
} from "@grit42/form";

const SHEET_OPTIONS_FORM_FIELDS: FormFieldDef[] = [
  {
    name: "include",
    display_name: "Include this sheet",
    type: "boolean",
  },
  {
    name: "columnDefinitionsFromSheetOptions.nameRowIndex",
    display_name: "Index of the row containing the column name",
    description: "name will be autogenerated if not specified",
    type: "integer",
    reference: "ignore",
    disabled: (ref) => ref,
  },
  {
    name: "columnDefinitionsFromSheetOptions.descriptionRowIndex",
    display_name: "Index of the row containing the column description",
    type: "integer",
    reference: "ignore",
    disabled: (ref) => ref,
  },
  {
    name: "columnDefinitionsFromSheetOptions.identifierRowIndex",
    display_name: "Index of the row containing the column safe_name",
    description: "safe_name will be autogenerated if not specified",
    type: "integer",
    reference: "ignore",
    disabled: (ref) => ref,
  },
  {
    name: "columnDefinitionsFromSheetOptions.dataRowOffset",
    display_name: "Index of the first row containing data",
    type: "number",
    reference: "ignore",
    disabled: (ref) => ref,
  },
  {
    name: "columnDefinitionsFromSheetOptions.columnOffset",
    display_name: "Index of the first column containing data",
    type: "string",
    reference: "ignore",
    disabled: (ref) => ref,
  },
];

const SheetOptions = ({
  form,
  sheetIndex,
}: {
  form: ReactFormExtendedApi<any>;
  sheetIndex: number;
  sheet: Sheet;
}) => {
  const fields = useMemo(
    () =>
      SHEET_OPTIONS_FORM_FIELDS.map((f) => ({
        ...f,
        reference: `sheets[${sheetIndex}].ignore`,
        name: `sheets[${sheetIndex}].${f.name}`,
      })),
    [sheetIndex],
  );

  return (
    <Surface>
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "1fr",
          gridAutoRows: "max-content",
          gap: "calc(var(--spacing) * 2)",
          paddingBottom: "calc(var(--spacing) * 2)",
        }}
      >
        {fields.map((f) => (
          <FormField form={form} fieldDef={f} key={f.name} />
        ))}
      </div>
    </Surface>
  );
};

const SheetPreview = ({
  sheet,
  onCellClick,
}: {
  sheet: Sheet;
  onCellClick: (
    row: number,
    column: string,
    cellRef: HTMLTableCellElement,
    cellData: any,
    event: React.MouseEvent<HTMLTableCellElement, MouseEvent>,
  ) => void;
}) => {
  const sampleData = useMemo(
    () => sampleSheetData(sheet).map((d, i) => ({ ...d, rowIndex: i + 1 })),
    [sheet],
  );

  const sampleDataColumns = useMemo(() => {
    const columns: GritColumnDef<Record<string, any>>[] = [
      {
        id: "rowIndex",
        header: "",
        accessorKey: "rowIndex",
        size: 40,
        type: "integer",
      },
    ];
    for (let i = 0; i <= sheet.range.e.c; i++) {
      const alphaCol = utils.encode_col(i);
      columns.push({
        id: alphaCol,
        header: alphaCol,
        accessorKey: alphaCol,
      });
    }
    return columns;
  }, [sheet]);

  const hanldeCellClick = useMemo(
    () =>
      [
        sampleDataColumns
          .filter(({ id }) => id !== "rowIndex")
          .map(({ id }) => id),
        (
          row: Row<Record<string, any>>,
          column: string,
          cellRef: HTMLTableCellElement,
          cellData: any,
          event: React.MouseEvent<HTMLTableCellElement, MouseEvent>,
        ) =>
          onCellClick(row.original.rowIndex, column, cellRef, cellData, event),
      ] as [
        columns: string[],
        callback: (row: Row<Record<string, any>>, columnName: string) => void,
      ],
    [sampleDataColumns, onCellClick],
  );

  return (
    <Table<Record<string, any>>
      onCellClick={hanldeCellClick}
      columns={sampleDataColumns}
      data={sampleData}
      settings={{
        disableFilters: true,
        disableColumnReorder: true,
        disableColumnSorting: true,
        disableVisibilitySettings: true,
      }}
    />
  );
};

const useDataTypeGuessMutation = () => {
  return useMutation({
    mutationKey: ["data_type_guess"],
    mutationFn: async (columns: any) => {
      const response = await request<
        EndpointSuccess<any>,
        EndpointError<EndpointErrorErrors<any>>
      >("/grit/core/data_types/guess_data_type_for_columns", {
        method: "POST",
        data: { columns },
      });

      if (!response.success) {
        throw response.errors;
      }

      return response.data;
    },
  });
};

export interface SheetWithColumns extends Sheet {
  columns: Column[];
  sort?: number;
}

const Wrapper = ({
  files,
  onSubmit,
}: {
  files: File[];
  onSubmit: (sheets: SheetWithColumns[]) => void;
}) => {
  const { data, isLoading, isError, error } = useQuery({
    queryKey: ["sheets", files],
    queryFn: async () => {
      return await sheetDefinitionsFromFiles(files);
    },
    enabled: files.length > 0,
  });

  if (!files?.length) {
    return <Navigate to="../files" />;
  }

  if (isLoading) {
    return <Spinner />;
  }

  if (isError || !data) {
    return <ErrorPage error={error?.message} />;
  }

  return <SheetMapper sheets={data} onSubmit={onSubmit} />;
};

const SheetMapper = ({
  sheets,
  onSubmit,
}: {
  sheets: Sheet[];
  onSubmit: (sheets: SheetWithColumns[]) => void;
}) => {
  const [focusedCellInfo, setFocusedCellInfo] = useState<{
    row: number;
    column: string;
  } | null>(null);
  const focusedCellRef = useRef<HTMLTableCellElement | null>(null);

  useEffect(() => {
    if (!focusedCellInfo) return;
    const cell = focusedCellRef.current;
    const parentDiv = cell?.closest("div");

    const clearCellInfo = () => {
      setFocusedCellInfo(null);
      focusedCellRef.current = null;
    };

    const clearCellInfoIfNotInView = () => {
      const parentRect = parentDiv?.getBoundingClientRect();
      const cellRect = cell?.getBoundingClientRect();

      const isCellVisible =
        parentRect &&
        cellRect &&
        cellRect.right < parentRect.right &&
        cellRect.left > parentRect.left &&
        cellRect.top > parentRect.top &&
        cellRect.bottom < parentRect.bottom;
      if (!isCellVisible) {
        setFocusedCellInfo(null);
        focusedCellRef.current = null;
      }
    };

    document.addEventListener("click", clearCellInfo);
    document.addEventListener("scroll", clearCellInfoIfNotInView, true);
    return () => {
      document.removeEventListener("click", clearCellInfo);
      document.removeEventListener("scroll", clearCellInfoIfNotInView, true);
    };
  }, [focusedCellInfo]);

  const dataTypeGuessMutation = useDataTypeGuessMutation();

  const form = useForm({
    defaultValues: {
      sheets: sheets.map((s) => ({
        ...s,
        columnDefinitionsFromSheetOptions:
          defaultColumnDefinitionsFromSheetOptions,
        include: true,
      })),
    },
    onSubmit: async ({ value }) => {
      const sheetsWithColumns = await Promise.all(
        value.sheets
          .filter((s) => s.include)
          .map(async (s, sIndex) => ({
            ...s,
            sort: sIndex,
            sample_data: sampleSheetData(s),
            columns: (await columnDefinitionsFromSheet(
              s,
              s.columnDefinitionsFromSheetOptions,
            )).map((c, cIndex) => ({
              ...c, sort: cIndex
            })),
          })) ?? [],
      );

      const string_columns_samples: any = {};
      sheetsWithColumns.forEach((s) =>
        s.columns
          .filter(({ detailed_data_type }) => detailed_data_type == "string")
          .forEach(({ excel_column, id }) => {
            string_columns_samples[id] = s.sample_data
              .slice(1)
              .map((s) => s[excel_column as string]);
          }),
      );

      const res = (
        await dataTypeGuessMutation.mutateAsync(string_columns_samples)
      ).reduce((acc: any, d: any) => ({ ...acc, [d.column_id]: d }), {});


      sheetsWithColumns.forEach((s) => {
        s.columns.forEach((c) => {
          if (res[c.id.toString()]) {
            c.detailed_data_type = res[c.id.toString()].data_type_name
          }
        });
      });

      onSubmit(sheetsWithColumns);
      navigate(`../edit`);
    },
  });

  const setFieldValue = (field: string, value: string | number) => {
    form.setFieldValue(`sheets[${selectedTab}].${field}` as any, value);
  };

  const handleCellClick = (
    row: number,
    column: string,
    cellRef: HTMLTableCellElement,
    _: any,
    event: React.MouseEvent<HTMLTableCellElement, MouseEvent>,
  ) => {
    if (focusedCellRef.current == cellRef) {
      focusedCellRef.current = null;
      setFocusedCellInfo(null);
    } else {
      focusedCellRef.current = cellRef;
      setFocusedCellInfo({ row, column });
    }
    event.stopPropagation();
  };

  const [selectedTab, setSelectedTab] = useState(0);
  const navigate = useNavigate();

  return (
    <>
      {focusedCellInfo !== null && (
        <Portal>
          <TooltipRender
            key={focusedCellInfo.column + focusedCellInfo.row}
            childRef={focusedCellRef.current}
            onTransitionEnd={() => {}}
            isHovering={true}
            className={styles.tooltip}
            content={
              <>
                <div style={{ textAlign: "center", padding: "var(--spacing)" }}>
                  {focusedCellInfo.column}:{focusedCellInfo.row}
                </div>
                <Menu
                  menuItems={[
                    {
                      id: "nameRowIndex",
                      text: "Use this row for name",
                      onClick: (e) => {
                        e.stopPropagation();
                        setFieldValue(
                          "columnDefinitionsFromSheetOptions.nameRowIndex",
                          focusedCellInfo.row,
                        );
                        setFocusedCellInfo(null);
                        focusedCellRef.current = null;
                      },
                    },
                    {
                      id: "descriptionRowIndex",
                      text: "Use this row for description",
                      onClick: (e) => {
                        e.stopPropagation();
                        setFieldValue(
                          "columnDefinitionsFromSheetOptions.descriptionRowIndex",
                          focusedCellInfo.row,
                        );
                        setFocusedCellInfo(null);
                        focusedCellRef.current = null;
                      },
                    },
                    {
                      id: "identifierRowIndex",
                      text: "Use this row for safe_name",
                      onClick: (e) => {
                        e.stopPropagation();
                        setFieldValue(
                          "columnDefinitionsFromSheetOptions.identifierRowIndex",
                          focusedCellInfo.row,
                        );
                        setFocusedCellInfo(null);
                        focusedCellRef.current = null;
                      },
                    },
                    {
                      id: "dataRowOffset",
                      text: "Use this row for data offset",
                      onClick: (e) => {
                        e.stopPropagation();
                        setFieldValue(
                          "columnDefinitionsFromSheetOptions.dataRowOffset",
                          focusedCellInfo.row,
                        );
                        setFocusedCellInfo(null);
                        focusedCellRef.current = null;
                      },
                    },
                    {
                      id: "dataColumnOffset",
                      text: "Use this column for data offset",
                      onClick: (e) => {
                        e.stopPropagation();
                        setFieldValue(
                          "columnDefinitionsFromSheetOptions.columnOffset",
                          focusedCellInfo.column,
                        );
                        setFocusedCellInfo(null);
                        focusedCellRef.current = null;
                      },
                    },
                  ]}
                />
              </>
            }
            autoPlacementOptions={{
              allowedPlacements: ["top", "bottom"],
            }}
          ></TooltipRender>
        </Portal>
      )}
      <Form form={form} className={styles.sheetMapperContainer}>
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "baseline",
          }}
        >
          <h3 style={{ alignSelf: "baseline", marginBottom: "1em" }}>
            Data sheet definitions import: choose sheets to import and provide
            information about their structure
          </h3>

          <ButtonGroup>
            <Button onClick={() => navigate("../files")}>
              Back to loader
            </Button>
            <form.Subscribe
              selector={(state) => [state.canSubmit, state.isSubmitting]}
              children={([canSubmit, isSubmitting]) => (
                <div className={styles.controls}>
                  <ButtonGroup>
                    <Button
                      color="secondary"
                      disabled={!canSubmit}
                      type="submit"
                      loading={isSubmitting}
                    >
                      Continue
                    </Button>
                  </ButtonGroup>
                </div>
              )}
            />
          </ButtonGroup>
        </div>
        <Tabs
          selectedTab={selectedTab}
          onTabChange={setSelectedTab}
          className={styles.tab}
          tabs={
            sheets.map((s, index) => ({
              panelProps: {
                style: { overflow: "auto" },
              },
              key: s.name,
              name: s.name,
              panel: (
                <div
                  style={{
                    overflow: "auto",
                    display: "grid",
                    gridTemplateColumns: "1fr max-content",
                    gridTemplateRows: "1fr",
                    gap: "var(--spacing)",
                    height: "100%",
                  }}
                >
                  <SheetPreview sheet={s} onCellClick={handleCellClick} />
                  <SheetOptions form={form} sheetIndex={index} sheet={s} />
                </div>
              ),
            })) ?? []
          }
        />
      </Form>
    </>
  );
};

export default Wrapper;
